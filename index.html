<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mandelbrot + GTA Embed</title>
  <style>
    /* Reset and base */
    * {
      margin: 0; padding: 0; box-sizing: border-box;
    }
    body {
      background: #111;
      color: #ccc;
      font-family: 'Fira Code', monospace, monospace;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      padding: 10px;
    }
    canvas {
      background: #222;
      display: block;
      max-width: 100vw;
      max-height: 60vh;
      margin-bottom: 20px;
      border: 1px solid #444;
    }
    .stats {
      text-align: center;
      margin-bottom: 10px;
      font-size: 14px;
      color: #bbb;
      user-select: none;
    }
    .iframe-wrapper {
      width: 600px;
      max-width: 90vw;
      height: 450px;
      border: 2px solid #444;
      box-shadow: 0 0 10px #333;
      overflow: hidden;
      border-radius: 8px;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }
  </style>
</head>
<body>

  <canvas id="canvas"></canvas>
  <div class="stats" id="stats">Loading...</div>

  <div class="iframe-wrapper">
    <iframe
      src="https://www.retrogames.cc/embed/38656-grand-theft-auto-chinatown-wars-usa-en-fr-de-es-it.html"
      allowfullscreen="true"
      webkitallowfullscreen="true"
      mozallowfullscreen="true"
      scrolling="no"
      loading="lazy"
      title="GTA Chinatown Wars"
    ></iframe>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const stats = document.getElementById('stats');

    let width, height;
    let zoom = 200;
    let offsetX = 0;
    let offsetY = 0;
    let maxIterations = 50;
    let escapeRadius = 4;

    // FPS tracking
    let fps = 0;
    let frames = 0;
    let lastTime = performance.now();

    function updateCanvasSize() {
      width = window.innerWidth;
      height = Math.min(window.innerHeight * 0.6, 500);
      canvas.width = width;
      canvas.height = height;
    }
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);

    // Mouse drag variables
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        offsetX -= dx;
        offsetY -= dy;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
      }
    });
    canvas.addEventListener('mouseup', () => { isDragging = false; });
    canvas.addEventListener('mouseout', () => { isDragging = false; });

    // Zoom with mouse wheel
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      // Adjust offset to zoom relative to mouse position
      offsetX = (offsetX - mouseX) * zoomFactor + mouseX;
      offsetY = (offsetY - mouseY) * zoomFactor + mouseY;

      zoom *= zoomFactor;

      updateMaxIterations();
    });

    // Adaptive max iterations for smooth rendering and detail on zoom
    function updateMaxIterations() {
      maxIterations = Math.min(500, Math.floor(50 + zoom / 4));
    }

    // Color generator - simplified grayscale for minimalistic effect
    function getColor(iter) {
      if (iter === maxIterations) return [30, 30, 30];
      const c = 200 - Math.floor((iter / maxIterations) * 200);
      return [c, c, c];
    }

    // Mandelbrot calculation
    function mandelbrot(x, y) {
      let real = x;
      let imag = y;
      for (let i = 0; i < maxIterations; i++) {
        const r2 = real * real;
        const i2 = imag * imag;
        if (r2 + i2 > escapeRadius * escapeRadius) return i;
        imag = 2 * real * imag + y;
        real = r2 - i2 + x;
      }
      return maxIterations;
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      const particleSize = Math.max(1, Math.floor(300 / zoom));
      
      for (let px = 0; px < width; px += particleSize) {
        for (let py = 0; py < height; py += particleSize) {
          const x0 = (px + offsetX - width / 2) / zoom;
          const y0 = (py + offsetY - height / 2) / zoom;
          const iter = mandelbrot(x0, y0);
          const [r, g, b] = getColor(iter);
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(px, py, particleSize, particleSize);
        }
      }

      // Update FPS counter every second
      frames++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frames;
        frames = 0;
        lastTime = now;
      }

      // Show stats
      stats.textContent = `FPS: ${fps} | Zoom: ${zoom.toFixed(2)} | Iterations: ${maxIterations} | Particle Size: ${particleSize}`;

      requestAnimationFrame(draw);
    }

    updateMaxIterations();
    draw();
  </script>

</body>
</html>
